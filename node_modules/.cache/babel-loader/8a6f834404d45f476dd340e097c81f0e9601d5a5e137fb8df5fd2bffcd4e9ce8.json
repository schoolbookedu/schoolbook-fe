{"ast":null,"code":"'use strict';\n\nconst Url = require('url');\nconst Minipass = require('minipass');\nconst Headers = require('./headers.js');\nconst {\n  exportNodeCompatibleHeaders\n} = Headers;\nconst Body = require('./body.js');\nconst {\n  clone,\n  extractContentType,\n  getTotalBytes\n} = Body;\nconst version = require('../package.json').version;\nconst defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;\nconst INTERNALS = Symbol('Request internals');\nconst {\n  parse: parseUrl,\n  format: formatUrl\n} = Url;\nconst isRequest = input => typeof input === 'object' && typeof input[INTERNALS] === 'object';\nconst isAbortSignal = signal => {\n  const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n  return !!(proto && proto.constructor.name === 'AbortSignal');\n};\nclass Request extends Body {\n  constructor(input) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const parsedURL = isRequest(input) ? Url.parse(input.url) : input && input.href ? Url.parse(input.href) : Url.parse(`${input}`);\n    if (isRequest(input)) init = {\n      ...input[INTERNALS],\n      ...init\n    };else if (!input || typeof input === 'string') input = {};\n    const method = (init.method || input.method || 'GET').toUpperCase();\n    const isGETHEAD = method === 'GET' || method === 'HEAD';\n    if ((init.body !== null && init.body !== undefined || isRequest(input) && input.body !== null) && isGETHEAD) throw new TypeError('Request with GET/HEAD method cannot have body');\n    const inputBody = init.body !== null && init.body !== undefined ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n    if (inputBody !== null && inputBody !== undefined && !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody);\n      if (contentType) headers.append('Content-Type', contentType);\n    }\n    const signal = 'signal' in init ? init.signal : null;\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal)) throw new TypeError('Expected signal must be an instanceof AbortSignal');\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = init;\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    };\n\n    // node-fetch-only options\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n  }\n  get method() {\n    return this[INTERNALS].method;\n  }\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL);\n  }\n  get headers() {\n    return this[INTERNALS].headers;\n  }\n  get redirect() {\n    return this[INTERNALS].redirect;\n  }\n  get signal() {\n    return this[INTERNALS].signal;\n  }\n  clone() {\n    return new Request(this);\n  }\n  get [Symbol.toStringTag]() {\n    return 'Request';\n  }\n  static getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS].parsedURL;\n    const headers = new Headers(request[INTERNALS].headers);\n\n    // fetch step 1.3\n    if (!headers.has('Accept')) headers.set('Accept', '*/*');\n\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');\n    if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');\n    if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== 'function') {\n      throw new Error('Cancellation of streamed requests with AbortSignal is not supported');\n    }\n\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    const contentLengthValue = (request.body === null || request.body === undefined) && /^(POST|PUT)$/i.test(request.method) ? '0' : request.body !== null && request.body !== undefined ? getTotalBytes(request) : null;\n    if (contentLengthValue) headers.set('Content-Length', contentLengthValue + '');\n\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has('User-Agent')) headers.set('User-Agent', defaultUserAgent);\n\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');\n    const agent = typeof request.agent === 'function' ? request.agent(parsedURL) : request.agent;\n    if (!headers.has('Connection') && !agent) headers.set('Connection', 'close');\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = request[INTERNALS];\n\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n\n    return {\n      ...parsedURL,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    };\n  }\n}\nmodule.exports = Request;\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  }\n});","map":{"version":3,"names":["Url","require","Minipass","Headers","exportNodeCompatibleHeaders","Body","clone","extractContentType","getTotalBytes","version","defaultUserAgent","INTERNALS","Symbol","parse","parseUrl","format","formatUrl","isRequest","input","isAbortSignal","signal","proto","Object","getPrototypeOf","constructor","name","Request","init","arguments","length","undefined","parsedURL","url","href","method","toUpperCase","isGETHEAD","body","TypeError","inputBody","timeout","size","headers","has","contentType","append","ca","cert","ciphers","clientCertEngine","crl","dhparam","ecdhCurve","family","honorCipherOrder","key","passphrase","pfx","rejectUnauthorized","process","env","NODE_TLS_REJECT_UNAUTHORIZED","secureOptions","secureProtocol","servername","sessionIdContext","redirect","follow","compress","counter","agent","toStringTag","getNodeRequestOptions","request","set","protocol","hostname","test","isStream","destroy","Error","contentLengthValue","module","exports","defineProperties","prototype","enumerable"],"sources":["/Users/user/node_modules/node-gyp/node_modules/minipass-fetch/lib/request.js"],"sourcesContent":["'use strict'\nconst Url = require('url')\nconst Minipass = require('minipass')\nconst Headers = require('./headers.js')\nconst { exportNodeCompatibleHeaders } = Headers\nconst Body = require('./body.js')\nconst { clone, extractContentType, getTotalBytes } = Body\n\nconst version = require('../package.json').version\nconst defaultUserAgent =\n  `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`\n\nconst INTERNALS = Symbol('Request internals')\n\nconst { parse: parseUrl, format: formatUrl } = Url\n\nconst isRequest = input =>\n  typeof input === 'object' && typeof input[INTERNALS] === 'object'\n\nconst isAbortSignal = signal => {\n  const proto = (\n    signal\n    && typeof signal === 'object'\n    && Object.getPrototypeOf(signal)\n  )\n  return !!(proto && proto.constructor.name === 'AbortSignal')\n}\n\nclass Request extends Body {\n  constructor (input, init = {}) {\n    const parsedURL = isRequest(input) ? Url.parse(input.url)\n      : input && input.href ? Url.parse(input.href)\n      : Url.parse(`${input}`)\n\n    if (isRequest(input))\n      init = { ...input[INTERNALS], ...init }\n    else if (!input || typeof input === 'string')\n      input = {}\n\n    const method = (init.method || input.method || 'GET').toUpperCase()\n    const isGETHEAD = method === 'GET' || method === 'HEAD'\n\n    if ((init.body !== null && init.body !== undefined ||\n        isRequest(input) && input.body !== null) && isGETHEAD)\n      throw new TypeError('Request with GET/HEAD method cannot have body')\n\n    const inputBody = init.body !== null && init.body !== undefined ? init.body\n      : isRequest(input) && input.body !== null ? clone(input)\n      : null\n\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0,\n    })\n\n    const headers = new Headers(init.headers || input.headers || {})\n\n    if (inputBody !== null && inputBody !== undefined &&\n        !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody)\n      if (contentType)\n        headers.append('Content-Type', contentType)\n    }\n\n    const signal = 'signal' in init ? init.signal\n      : null\n\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal))\n      throw new TypeError('Expected signal must be an instanceof AbortSignal')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = init\n\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n\n    // node-fetch-only options\n    this.follow = init.follow !== undefined ? init.follow\n      : input.follow !== undefined ? input.follow\n      : 20\n    this.compress = init.compress !== undefined ? init.compress\n      : input.compress !== undefined ? input.compress\n      : true\n    this.counter = init.counter || input.counter || 0\n    this.agent = init.agent || input.agent\n  }\n\n  get method() {\n    return this[INTERNALS].method\n  }\n\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL)\n  }\n\n  get headers() {\n    return this[INTERNALS].headers\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect\n  }\n\n  get signal() {\n    return this[INTERNALS].signal\n  }\n\n  clone () {\n    return new Request(this)\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Request'\n  }\n\n  static getNodeRequestOptions (request) {\n    const parsedURL = request[INTERNALS].parsedURL\n    const headers = new Headers(request[INTERNALS].headers)\n\n    // fetch step 1.3\n    if (!headers.has('Accept'))\n      headers.set('Accept', '*/*')\n\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname)\n      throw new TypeError('Only absolute URLs are supported')\n\n    if (!/^https?:$/.test(parsedURL.protocol))\n      throw new TypeError('Only HTTP(S) protocols are supported')\n\n    if (request.signal &&\n        Minipass.isStream(request.body) &&\n        typeof request.body.destroy !== 'function') {\n      throw new Error(\n        'Cancellation of streamed requests with AbortSignal is not supported')\n    }\n\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    const contentLengthValue =\n      (request.body === null || request.body === undefined) &&\n        /^(POST|PUT)$/i.test(request.method) ? '0'\n      : request.body !== null && request.body !== undefined\n        ? getTotalBytes(request)\n      : null\n\n    if (contentLengthValue)\n      headers.set('Content-Length', contentLengthValue + '')\n\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has('User-Agent'))\n      headers.set('User-Agent', defaultUserAgent)\n\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has('Accept-Encoding'))\n      headers.set('Accept-Encoding', 'gzip,deflate')\n\n    const agent = typeof request.agent === 'function'\n      ? request.agent(parsedURL)\n      : request.agent\n\n    if (!headers.has('Connection') && !agent)\n      headers.set('Connection', 'close')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = request[INTERNALS]\n\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n\n    return {\n      ...parsedURL,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n  }\n}\n\nmodule.exports = Request\n\nObject.defineProperties(Request.prototype, {\n  method: { enumerable: true },\n  url: { enumerable: true },\n  headers: { enumerable: true },\n  redirect: { enumerable: true },\n  clone: { enumerable: true },\n  signal: { enumerable: true },\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"const {\n  dirname,\n  join,\n  resolve,\n  relative,\n  isAbsolute\n} = require('path');\nconst rimraf_ = require('rimraf');\nconst {\n  promisify\n} = require('util');\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs');\nconst access = promisify(access_);\nconst copyFile = promisify(copyFile_);\nconst unlink = promisify(unlink_);\nconst readdir = promisify(readdir_);\nconst rename = promisify(rename_);\nconst stat = promisify(stat_);\nconst lstat = promisify(lstat_);\nconst symlink = promisify(symlink_);\nconst readlink = promisify(readlink_);\nconst rimraf = promisify(rimraf_);\nconst rimrafSync = rimraf_.sync;\nconst mkdirp = require('mkdirp');\nconst pathExists = async path => {\n  try {\n    await access(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\nconst pathExistsSync = path => {\n  try {\n    accessSync(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\nconst moveFile = async function (source, destination) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n  options = {\n    overwrite: true,\n    ...options\n  };\n  if (!options.overwrite && (await pathExists(destination))) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n  await mkdirp(dirname(destination));\n  try {\n    await rename(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source);\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source);\n        await Promise.all(files.map(file => moveFile(join(source, file), join(destination, file), options, false, symlinks)));\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        await copyFile(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n  if (root) {\n    await Promise.all(symlinks.map(async _ref => {\n      let {\n        source,\n        destination\n      } = _ref;\n      let target = await readlink(source);\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target)) target = resolve(destination, relative(source, target));\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat;\n      try {\n        targetStat = await stat(resolve(dirname(source), target));\n      } catch (err) {}\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n    }));\n    await rimraf(source);\n  }\n};\nconst moveFileSync = function (source, destination) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n  options = {\n    overwrite: true,\n    ...options\n  };\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n  mkdirp.sync(dirname(destination));\n  try {\n    renameSync(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source);\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source);\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks);\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        copyFileSync(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n  if (root) {\n    for (const {\n      source,\n      destination\n    } of symlinks) {\n      let target = readlinkSync(source);\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target)) target = resolve(destination, relative(source, target));\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat;\n      try {\n        targetStat = statSync(resolve(dirname(source), target));\n      } catch (err) {}\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n    }\n    rimrafSync(source);\n  }\n};\nmodule.exports = moveFile;\nmodule.exports.sync = moveFileSync;","map":{"version":3,"names":["dirname","join","resolve","relative","isAbsolute","require","rimraf_","promisify","access","access_","accessSync","copyFile","copyFile_","copyFileSync","unlink","unlink_","unlinkSync","readdir","readdir_","readdirSync","rename","rename_","renameSync","stat","stat_","statSync","lstat","lstat_","lstatSync","symlink","symlink_","symlinkSync","readlink","readlink_","readlinkSync","rimraf","rimrafSync","sync","mkdirp","pathExists","path","er","code","pathExistsSync","moveFile","source","destination","options","arguments","length","undefined","root","symlinks","TypeError","overwrite","Error","error","sourceStat","isDirectory","files","Promise","all","map","file","isSymbolicLink","push","_ref","target","targetStat","err","moveFileSync","module","exports"],"sources":["/Users/user/node_modules/node-gyp/node_modules/@npmcli/move-file/index.js"],"sourcesContent":["const { dirname, join, resolve, relative, isAbsolute } = require('path')\nconst rimraf_ = require('rimraf')\nconst { promisify } = require('util')\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs')\n\nconst access = promisify(access_)\nconst copyFile = promisify(copyFile_)\nconst unlink = promisify(unlink_)\nconst readdir = promisify(readdir_)\nconst rename = promisify(rename_)\nconst stat = promisify(stat_)\nconst lstat = promisify(lstat_)\nconst symlink = promisify(symlink_)\nconst readlink = promisify(readlink_)\nconst rimraf = promisify(rimraf_)\nconst rimrafSync = rimraf_.sync\n\nconst mkdirp = require('mkdirp')\n\nconst pathExists = async path => {\n  try {\n    await access(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && await pathExists(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  await mkdirp(dirname(destination))\n\n  try {\n    await rename(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source)\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source)\n        await Promise.all(files.map((file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)))\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        await copyFile(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async ({ source, destination }) => {\n      let target = await readlink(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = await stat(resolve(dirname(source), target))\n      } catch (err) {}\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }))\n    await rimraf(source)\n  }\n}\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  mkdirp.sync(dirname(destination))\n\n  try {\n    renameSync(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source)\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source)\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks)\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        copyFileSync(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    for (const { source, destination } of symlinks) {\n      let target = readlinkSync(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = statSync(resolve(dirname(source), target))\n      } catch (err) {}\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }\n    rimrafSync(source)\n  }\n}\n\nmodule.exports = moveFile\nmodule.exports.sync = moveFileSync\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
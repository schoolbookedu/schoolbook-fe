{"ast":null,"code":"'use strict';\n\nconst Minipass = require('minipass');\nconst MinipassSized = require('minipass-sized');\nconst Blob = require('./blob.js');\nconst {\n  BUFFER\n} = Blob;\nconst FetchError = require('./fetch-error.js');\n\n// optional dependency on 'encoding'\nlet convert;\ntry {\n  convert = require('encoding').convert;\n} catch (e) {}\nconst INTERNALS = Symbol('Body internals');\nconst CONSUME_BODY = Symbol('consumeBody');\nclass Body {\n  constructor(bodyArg) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      size = 0,\n      timeout = 0\n    } = options;\n    const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n  get body() {\n    return this[INTERNALS].body;\n  }\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  arrayBuffer() {\n    return this[CONSUME_BODY]().then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  }\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return this[CONSUME_BODY]().then(buf => Object.assign(new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  }\n  json() {\n    return this[CONSUME_BODY]().then(buf => {\n      try {\n        return JSON.parse(buf.toString());\n      } catch (er) {\n        return Promise.reject(new FetchError(`invalid json response body at ${this.url} reason: ${er.message}`, 'invalid-json'));\n      }\n    });\n  }\n  text() {\n    return this[CONSUME_BODY]().then(buf => buf.toString());\n  }\n  buffer() {\n    return this[CONSUME_BODY]();\n  }\n  textConverted() {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers));\n  }\n  [CONSUME_BODY]() {\n    if (this[INTERNALS].disturbed) return Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) return Promise.reject(this[INTERNALS].error);\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n    if (Buffer.isBuffer(this.body)) return Promise.resolve(this.body);\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body;\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream)) return Promise.resolve(Buffer.alloc(0));\n    const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({\n      size: this.size\n    }) : new Minipass();\n\n    // allow timeout on slow response body\n    const resTimeout = this.timeout ? setTimeout(() => {\n      stream.emit('error', new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n    }, this.timeout) : null;\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout) {\n      resTimeout.unref();\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er));\n        upstream.pipe(stream);\n      }\n      resolve();\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout);\n      return buf;\n    }).catch(er => {\n      clearTimeout(resTimeout);\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError') throw er;else if (er.name === 'RangeError') throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, 'system', er);else\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n    });\n  }\n  static clone(instance) {\n    if (instance.bodyUsed) throw new Error('cannot clone body after it is used');\n    const body = instance.body;\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass();\n      const p1 = new Minipass();\n      const p2 = new Minipass();\n      tee.on('error', er => {\n        p1.emit('error', er);\n        p2.emit('error', er);\n      });\n      body.on('error', er => tee.emit('error', er));\n      tee.pipe(p1);\n      tee.pipe(p2);\n      body.pipe(tee);\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1;\n      return p2;\n    } else return instance.body;\n  }\n  static extractContentType(body) {\n    return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';\n  }\n  static getTotalBytes(instance) {\n    const {\n      body\n    } = instance;\n    return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && (\n    // detect form data input from form-data module\n    body._lengthRetrievers && /* istanbul ignore next */body._lengthRetrievers.length == 0 ||\n    // 1.x\n    body.hasKnownLength && body.hasKnownLength()) // 2.x\n    ? body.getLengthSync() : null;\n  }\n  static writeToStream(dest, instance) {\n    const {\n      body\n    } = instance;\n    if (body === null || body === undefined) dest.end();else if (Buffer.isBuffer(body) || typeof body === 'string') dest.end(body);else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body;\n      stream.on('error', er => dest.emit('error', er)).pipe(dest);\n    }\n    return dest;\n  }\n}\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\nconst isURLSearchParams = obj =>\n// Duck-typing as a necessary condition.\ntypeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false\n// Brand-checking and more duck-typing as optional condition.\n: obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\nconst isBlob = obj => typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  const ct = headers && headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str;\n\n  // header\n  if (ct) res = /charset=([^;]*)/i.exec(ct);\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString();\n\n  // html5\n  if (!res && str) res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n      if (res) res.pop(); // drop last quote\n    }\n\n    if (res) res = /charset=(.*)/i.exec(res.pop());\n  }\n\n  // xml\n  if (!res && str) res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\n  // found charset\n  if (res) {\n    charset = res.pop();\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') charset = 'gb18030';\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(buffer, 'UTF-8', charset).toString();\n};\nmodule.exports = Body;","map":{"version":3,"names":["Minipass","require","MinipassSized","Blob","BUFFER","FetchError","convert","e","INTERNALS","Symbol","CONSUME_BODY","Body","constructor","bodyArg","options","arguments","length","undefined","size","timeout","body","isURLSearchParams","Buffer","from","toString","isBlob","isBuffer","Object","prototype","call","ArrayBuffer","isView","buffer","byteOffset","byteLength","isStream","String","disturbed","error","on","er","name","url","message","bodyUsed","arrayBuffer","then","buf","slice","blob","ct","headers","get","assign","type","toLowerCase","json","JSON","parse","Promise","reject","text","textConverted","convertBody","TypeError","resolve","alloc","upstream","stream","resTimeout","setTimeout","emit","unref","pipe","concat","clearTimeout","catch","clone","instance","Error","getBoundary","tee","p1","p2","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","defineProperties","enumerable","obj","append","delete","getAll","has","set","sort","test","toStringTag","charset","res","str","exec","pop","module","exports"],"sources":["/Users/user/node_modules/node-gyp/node_modules/minipass-fetch/lib/body.js"],"sourcesContent":["'use strict'\nconst Minipass = require('minipass')\nconst MinipassSized = require('minipass-sized')\n\nconst Blob = require('./blob.js')\nconst {BUFFER} = Blob\nconst FetchError = require('./fetch-error.js')\n\n// optional dependency on 'encoding'\nlet convert\ntry {\n  convert = require('encoding').convert\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals')\nconst CONSUME_BODY = Symbol('consumeBody')\n\nclass Body {\n  constructor (bodyArg, options = {}) {\n    const { size = 0, timeout = 0 } = options\n    const body = bodyArg === undefined || bodyArg === null ? null\n      : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString())\n      : isBlob(bodyArg) ? bodyArg\n      : Buffer.isBuffer(bodyArg) ? bodyArg\n      : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]'\n        ? Buffer.from(bodyArg)\n      : ArrayBuffer.isView(bodyArg)\n        ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength)\n      : Minipass.isStream(bodyArg) ? bodyArg\n      : Buffer.from(String(bodyArg))\n\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null,\n    }\n\n    this.size = size\n    this.timeout = timeout\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er\n          : new FetchError(`Invalid response while trying to fetch ${\n            this.url}: ${er.message}`, 'system', er)\n        this[INTERNALS].error = error\n      })\n    }\n  }\n\n  get body () {\n    return this[INTERNALS].body\n  }\n\n  get bodyUsed () {\n    return this[INTERNALS].disturbed\n  }\n\n  arrayBuffer () {\n    return this[CONSUME_BODY]().then(buf =>\n      buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  }\n\n  blob () {\n    const ct = this.headers && this.headers.get('content-type') || ''\n    return this[CONSUME_BODY]().then(buf => Object.assign(\n      new Blob([], { type: ct.toLowerCase() }),\n      { [BUFFER]: buf }\n    ))\n  }\n\n  json () {\n    return this[CONSUME_BODY]().then(buf => {\n      try {\n        return JSON.parse(buf.toString())\n      } catch (er) {\n        return Promise.reject(new FetchError(\n          `invalid json response body at ${\n            this.url} reason: ${er.message}`, 'invalid-json'))\n      }\n    })\n  }\n\n  text () {\n    return this[CONSUME_BODY]().then(buf => buf.toString())\n  }\n\n  buffer () {\n    return this[CONSUME_BODY]()\n  }\n\n  textConverted () {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers))\n  }\n\n  [CONSUME_BODY] () {\n    if (this[INTERNALS].disturbed)\n      return Promise.reject(new TypeError(`body used already for: ${\n        this.url}`))\n\n    this[INTERNALS].disturbed = true\n\n    if (this[INTERNALS].error)\n      return Promise.reject(this[INTERNALS].error)\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    if (Buffer.isBuffer(this.body))\n      return Promise.resolve(this.body)\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream))\n      return Promise.resolve(Buffer.alloc(0))\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream\n      : !this.size && upstream instanceof Minipass &&\n        !(upstream instanceof MinipassSized) ? upstream\n      : this.size ? new MinipassSized({ size: this.size })\n      : new Minipass()\n\n    // allow timeout on slow response body\n    const resTimeout = this.timeout ? setTimeout(() => {\n      stream.emit('error', new FetchError(\n        `Response timeout while trying to fetch ${\n          this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n    }, this.timeout) : null\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout) {\n      resTimeout.unref()\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er))\n        upstream.pipe(stream)\n      }\n      resolve()\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout)\n      return buf\n    }).catch(er => {\n      clearTimeout(resTimeout)\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError')\n        throw er\n      else if (er.name === 'RangeError')\n        throw new FetchError(`Could not create Buffer from response body for ${\n          this.url}: ${er.message}`, 'system', er)\n      else\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${\n          this.url}: ${er.message}`, 'system', er)\n    })\n  }\n\n  static clone (instance) {\n    if (instance.bodyUsed)\n      throw new Error('cannot clone body after it is used')\n\n    const body = instance.body\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass()\n      const p1 = new Minipass()\n      const p2 = new Minipass()\n      tee.on('error', er => {\n        p1.emit('error', er)\n        p2.emit('error', er)\n      })\n      body.on('error', er => tee.emit('error', er))\n      tee.pipe(p1)\n      tee.pipe(p2)\n      body.pipe(tee)\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1\n      return p2\n    } else\n      return instance.body\n  }\n\n  static extractContentType (body) {\n    return body === null || body === undefined ? null\n      : typeof body === 'string' ? 'text/plain;charset=UTF-8'\n      : isURLSearchParams(body)\n        ? 'application/x-www-form-urlencoded;charset=UTF-8'\n      : isBlob(body) ? body.type || null\n      : Buffer.isBuffer(body) ? null\n      : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null\n      : ArrayBuffer.isView(body) ? null\n      : typeof body.getBoundary === 'function'\n        ? `multipart/form-data;boundary=${body.getBoundary()}`\n      : Minipass.isStream(body) ? null\n      : 'text/plain;charset=UTF-8'\n  }\n\n  static getTotalBytes (instance) {\n    const {body} = instance\n    return (body === null || body === undefined) ? 0\n    : isBlob(body) ? body.size\n    : Buffer.isBuffer(body) ? body.length\n    : body && typeof body.getLengthSync === 'function' && (\n        // detect form data input from form-data module\n        body._lengthRetrievers &&\n        /* istanbul ignore next */ body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) // 2.x\n      ? body.getLengthSync()\n    : null\n  }\n\n  static writeToStream (dest, instance) {\n    const {body} = instance\n\n    if (body === null || body === undefined)\n      dest.end()\n    else if (Buffer.isBuffer(body) || typeof body === 'string')\n      dest.end(body)\n    else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body\n      stream.on('error', er => dest.emit('error', er)).pipe(dest)\n    }\n\n    return dest\n  }\n}\n\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true }\n})\n\n\nconst isURLSearchParams = obj =>\n  // Duck-typing as a necessary condition.\n  (typeof obj !== 'object' ||\n    typeof obj.append !== 'function' ||\n    typeof obj.delete !== 'function' ||\n    typeof obj.get !== 'function' ||\n    typeof obj.getAll !== 'function' ||\n    typeof obj.has !== 'function' ||\n    typeof obj.set !== 'function') ? false\n  // Brand-checking and more duck-typing as optional condition.\n  : obj.constructor.name === 'URLSearchParams' ||\n    Object.prototype.toString.call(obj) === '[object URLSearchParams]' ||\n    typeof obj.sort === 'function'\n\nconst isBlob = obj =>\n  typeof obj === 'object' &&\n  typeof obj.arrayBuffer === 'function' &&\n  typeof obj.type === 'string' &&\n  typeof obj.stream === 'function' &&\n  typeof obj.constructor === 'function' &&\n  typeof obj.constructor.name === 'string' &&\n  /^(Blob|File)$/.test(obj.constructor.name) &&\n  /^(Blob|File)$/.test(obj[Symbol.toStringTag])\n\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function')\n    throw new Error('The package `encoding` must be installed to use the textConverted() function')\n\n  const ct = headers && headers.get('content-type')\n  let charset = 'utf-8'\n  let res, str\n\n  // header\n  if (ct)\n    res = /charset=([^;]*)/i.exec(ct)\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str)\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str)\n      if (res)\n        res.pop() // drop last quote\n    }\n\n    if (res)\n      res = /charset=(.*)/i.exec(res.pop())\n  }\n\n  // xml\n  if (!res && str)\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk')\n      charset = 'gb18030'\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer,\n    'UTF-8',\n    charset\n  ).toString()\n}\n\nmodule.exports = Body\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
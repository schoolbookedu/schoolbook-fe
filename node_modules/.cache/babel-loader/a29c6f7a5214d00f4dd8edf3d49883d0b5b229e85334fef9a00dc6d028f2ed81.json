{"ast":null,"code":"const {\n  Request,\n  Response\n} = require('minipass-fetch');\nconst Minipass = require('minipass');\nconst MinipassCollect = require('minipass-collect');\nconst MinipassFlush = require('minipass-flush');\nconst MinipassPipeline = require('minipass-pipeline');\nconst cacache = require('cacache');\nconst url = require('url');\nconst CachePolicy = require('./policy.js');\nconst cacheKey = require('./key.js');\nconst remote = require('../remote.js');\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\nconst MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control'];\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'location', 'pragma', 'vary'];\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {}\n  };\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304) metadata.status = response.status;\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host');\n  const parsedUrl = new url.URL(request.url);\n  if (host && parsedUrl.host !== host) metadata.reqHeaders.host = host;\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary');\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n      for (const name of varyHeaders) {\n        // explicitly ignore accept-encoding here\n        if (name !== 'accept-encoding' && request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);\n      }\n    }\n  }\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) metadata.resHeaders[name] = response.headers.get(name);\n  }\n\n  // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding');\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding');\n  }\n  return metadata;\n};\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request');\nconst _response = Symbol('response');\nconst _policy = Symbol('policy');\nclass CacheEntry {\n  constructor(_ref) {\n    let {\n      entry,\n      request,\n      response,\n      options\n    } = _ref;\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry;\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else this.key = cacheKey(request);\n    this.options = options;\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find(request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({\n          entry: A,\n          options\n        });\n        const entryB = new CacheEntry({\n          entry: B,\n          options\n        });\n        return entryA.policy.satisfies(entryB.request);\n      }, {\n        validateEntry: entry => {\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null) return !!(entry.metadata && entry.metadata.status);\n          return true;\n        }\n      });\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return;\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload') return;\n\n    // find the specific entry that satisfies the request\n    let match;\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options\n      });\n      if (_entry.policy.satisfies(request)) {\n        match = _entry;\n        break;\n      }\n    }\n    return match;\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate(request, options) {\n    const key = cacheKey(request);\n    try {\n      await cacache.rm.entry(options.cachePath, key, {\n        removeFully: true\n      });\n    } catch (err) {\n      // ignore errors\n    }\n  }\n  get request() {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders\n      });\n    }\n    return this[_request];\n  }\n  get response() {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size\n        }\n      });\n    }\n    return this[_response];\n  }\n  get policy() {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options\n      });\n    }\n    return this[_policy];\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store(status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {\n      this.response.headers.set('x-local-cache-status', 'skip');\n      return this.response;\n    }\n    const size = this.response.headers.get('content-length');\n    const fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE;\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory;\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      memoize: fitsInMemory && this.options.memoize\n    };\n    let body = null;\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject;\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve;\n        cacheWriteReject = reject;\n      });\n      body = new MinipassPipeline(new MinipassFlush({\n        flush() {\n          return cacheWritePromise;\n        }\n      }));\n      let abortStream, onResume;\n      if (shouldBuffer) {\n        // if the result fits in memory, use a collect stream to gather\n        // the response and write it to cacache while also passing it through\n        // to the user\n        onResume = () => {\n          const collector = new MinipassCollect.PassThrough();\n          abortStream = collector;\n          collector.on('collect', data => {\n            // TODO if the cache write fails, log a warning but return the response anyway\n            cacache.put(this.options.cachePath, this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject);\n          });\n          body.unshift(collector);\n          body.unshift(this.response.body);\n        };\n      } else {\n        // if it does not fit in memory, create a tee stream and use\n        // that to pipe to both the cache and the user simultaneously\n        onResume = () => {\n          const tee = new Minipass();\n          const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts);\n          abortStream = cacheStream;\n          tee.pipe(cacheStream);\n          // TODO if the cache write fails, log a warning but return the response anyway\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n          body.unshift(tee);\n          body.unshift(this.response.body);\n        };\n      }\n      body.once('resume', onResume);\n      body.once('end', () => body.removeListener('resume', onResume));\n      this.response.body.on('error', err => {\n        // the abortStream will either be a MinipassCollect if we buffer\n        // or a cacache write stream, either way be sure to listen for\n        // errors from the actual response and avoid writing data that we\n        // know to be invalid to the cache\n        abortStream.destroy(err);\n      });\n    } else await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts);\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n    this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n    this.response.headers.set('x-local-cache-status', status);\n    this.response.headers.set('x-local-cache-time', new Date().toISOString());\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter\n    });\n    return newResponse;\n  }\n\n  // use the cached data to create a response and return it\n  async respond(method, options, status) {\n    let response;\n    const size = Number(this.response.headers.get('content-length'));\n    const fitsInMemory = !!size && size < MAX_MEM_SIZE;\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory;\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response;\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass();\n      const removeOnResume = () => body.removeListener('resume', onResume);\n      let onResume;\n      if (shouldBuffer) {\n        onResume = async () => {\n          removeOnResume();\n          try {\n            const content = await cacache.get.byDigest(this.options.cachePath, this.entry.integrity, {\n              memoize: this.options.memoize\n            });\n            body.end(content);\n          } catch (err) {\n            if (err.code === 'EINTEGRITY') await cacache.rm.content(this.options.cachePath, this.entry.integrity, {\n              memoize: this.options.memoize\n            });\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') await CacheEntry.invalidate(this.request, this.options);\n            body.emit('error', err);\n          }\n        };\n      } else {\n        onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, {\n            memoize: this.options.memoize\n          });\n          cacheStream.on('error', async err => {\n            cacheStream.pause();\n            if (err.code === 'EINTEGRITY') await cacache.rm.content(this.options.cachePath, this.entry.integrity, {\n              memoize: this.options.memoize\n            });\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') await CacheEntry.invalidate(this.request, this.options);\n            body.emit('error', err);\n            cacheStream.resume();\n          });\n          cacheStream.pipe(body);\n        };\n      }\n      body.once('resume', onResume);\n      body.once('end', removeOnResume);\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers: {\n          ...this.policy.responseHeaders()\n        }\n      });\n    }\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity));\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n    response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n    response.headers.set('x-local-cache-status', status);\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString());\n    return response;\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate(request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request)\n    });\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined\n      });\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate) return this.respond(request.method, options, 'stale');\n      throw err;\n    }\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options);\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];\n      }\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata\n        });\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated');\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options\n    });\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated');\n  }\n}\nmodule.exports = CacheEntry;","map":{"version":3,"names":["Request","Response","require","Minipass","MinipassCollect","MinipassFlush","MinipassPipeline","cacache","url","CachePolicy","cacheKey","remote","hasOwnProperty","obj","prop","Object","prototype","call","MAX_MEM_SIZE","KEEP_REQUEST_HEADERS","KEEP_RESPONSE_HEADERS","getMetadata","request","response","options","metadata","time","Date","now","reqHeaders","resHeaders","status","name","headers","has","get","host","parsedUrl","URL","vary","varyHeaders","trim","toLowerCase","split","compress","_request","Symbol","_response","_policy","CacheEntry","constructor","_ref","entry","key","find","matches","index","compact","cachePath","A","B","entryA","entryB","policy","satisfies","validateEntry","integrity","err","cache","match","_entry","invalidate","rm","removeFully","method","counter","size","store","includes","storable","set","fitsInMemory","Number","shouldBuffer","memoize","cacheOpts","algorithms","body","cacheWriteResolve","cacheWriteReject","cacheWritePromise","Promise","resolve","reject","flush","abortStream","onResume","collector","PassThrough","on","data","put","then","unshift","tee","cacheStream","stream","pipe","promise","once","removeListener","destroy","insert","encodeURIComponent","toISOString","newResponse","respond","removeOnResume","content","byDigest","end","code","emit","pause","resume","responseHeaders","toUTCString","revalidate","revalidateRequest","revalidationHeaders","undefined","mustRevalidate","revalidated","newEntry","module","exports"],"sources":["/Users/user/node_modules/node-gyp/node_modules/make-fetch-happen/lib/cache/entry.js"],"sourcesContent":["const { Request, Response } = require('minipass-fetch')\nconst Minipass = require('minipass')\nconst MinipassCollect = require('minipass-collect')\nconst MinipassFlush = require('minipass-flush')\nconst MinipassPipeline = require('minipass-pipeline')\nconst cacache = require('cacache')\nconst url = require('url')\n\nconst CachePolicy = require('./policy.js')\nconst cacheKey = require('./key.js')\nconst remote = require('../remote.js')\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\n// maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = [\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept',\n  'cache-control',\n]\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = [\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-type',\n  'date',\n  'etag',\n  'expires',\n  'last-modified',\n  'location',\n  'pragma',\n  'vary',\n]\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n  }\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304)\n    metadata.status = response.status\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name))\n      metadata.reqHeaders[name] = request.headers.get(name)\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host')\n  const parsedUrl = new url.URL(request.url)\n  if (host && parsedUrl.host !== host)\n    metadata.reqHeaders.host = host\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary')\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/)\n      for (const name of varyHeaders) {\n        // explicitly ignore accept-encoding here\n        if (name !== 'accept-encoding' && request.headers.has(name))\n          metadata.reqHeaders[name] = request.headers.get(name)\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name))\n      metadata.resHeaders[name] = response.headers.get(name)\n  }\n\n  // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding')\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding')\n  }\n\n  return metadata\n}\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request')\nconst _response = Symbol('response')\nconst _policy = Symbol('policy')\n\nclass CacheEntry {\n  constructor ({ entry, request, response, options }) {\n    if (entry) {\n      this.key = entry.key\n      this.entry = entry\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time\n    } else\n      this.key = cacheKey(request)\n\n    this.options = options\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request\n    this[_response] = response\n    this[_policy] = null\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find (request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({ entry: A, options })\n        const entryB = new CacheEntry({ entry: B, options })\n        return entryA.policy.satisfies(entryB.request)\n      }, {\n        validateEntry: (entry) => {\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null)\n            return !!(entry.metadata && entry.metadata.status)\n\n          return true\n        },\n      })\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload')\n      return\n\n    // find the specific entry that satisfies the request\n    let match\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options,\n      })\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry\n        break\n      }\n    }\n\n    return match\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate (request, options) {\n    const key = cacheKey(request)\n    try {\n      await cacache.rm.entry(options.cachePath, key, { removeFully: true })\n    } catch (err) {\n      // ignore errors\n    }\n  }\n\n  get request () {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n      })\n    }\n\n    return this[_request]\n  }\n\n  get response () {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size,\n        },\n      })\n    }\n\n    return this[_response]\n  }\n\n  get policy () {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options,\n      })\n    }\n\n    return this[_policy]\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store (status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {\n      this.response.headers.set('x-local-cache-status', 'skip')\n      return this.response\n    }\n\n    const size = this.response.headers.get('content-length')\n    const fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      memoize: fitsInMemory && this.options.memoize,\n    }\n\n    let body = null\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve\n        cacheWriteReject = reject\n      })\n\n      body = new MinipassPipeline(new MinipassFlush({\n        flush () {\n          return cacheWritePromise\n        },\n      }))\n\n      let abortStream, onResume\n      if (shouldBuffer) {\n        // if the result fits in memory, use a collect stream to gather\n        // the response and write it to cacache while also passing it through\n        // to the user\n        onResume = () => {\n          const collector = new MinipassCollect.PassThrough()\n          abortStream = collector\n          collector.on('collect', (data) => {\n            // TODO if the cache write fails, log a warning but return the response anyway\n            cacache.put(this.options.cachePath, this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject)\n          })\n          body.unshift(collector)\n          body.unshift(this.response.body)\n        }\n      } else {\n        // if it does not fit in memory, create a tee stream and use\n        // that to pipe to both the cache and the user simultaneously\n        onResume = () => {\n          const tee = new Minipass()\n          const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts)\n          abortStream = cacheStream\n          tee.pipe(cacheStream)\n          // TODO if the cache write fails, log a warning but return the response anyway\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n          body.unshift(tee)\n          body.unshift(this.response.body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n      this.response.body.on('error', (err) => {\n        // the abortStream will either be a MinipassCollect if we buffer\n        // or a cacache write stream, either way be sure to listen for\n        // errors from the actual response and avoid writing data that we\n        // know to be invalid to the cache\n        abortStream.destroy(err)\n      })\n    } else\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts)\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    this.response.headers.set('x-local-cache-status', status)\n    this.response.headers.set('x-local-cache-time', new Date().toISOString())\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter,\n    })\n    return newResponse\n  }\n\n  // use the cached data to create a response and return it\n  async respond (method, options, status) {\n    let response\n    const size = Number(this.response.headers.get('content-length'))\n    const fitsInMemory = !!size && size < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass()\n      const removeOnResume = () => body.removeListener('resume', onResume)\n      let onResume\n      if (shouldBuffer) {\n        onResume = async () => {\n          removeOnResume()\n          try {\n            const content = await cacache.get.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            body.end(content)\n          } catch (err) {\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n          }\n        }\n      } else {\n        onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n          cacheStream.on('error', async (err) => {\n            cacheStream.pause()\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n            cacheStream.resume()\n          })\n          cacheStream.pipe(body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', removeOnResume)\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers: {\n          ...this.policy.responseHeaders(),\n        },\n      })\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity))\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    response.headers.set('x-local-cache-status', status)\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString())\n    return response\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate (request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request),\n    })\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined,\n      })\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate)\n        return this.respond(request.method, options, 'stale')\n\n      throw err\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options)\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name))\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata,\n        })\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated')\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options,\n    })\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated')\n  }\n}\n\nmodule.exports = CacheEntry\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
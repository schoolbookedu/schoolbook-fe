{"ast":null,"code":"'use strict';\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nconst validateName = name => {\n  name = `${name}`;\n  if (invalidTokenRegex.test(name) || name === '') throw new TypeError(`${name} is not a legal HTTP header name`);\n};\nconst validateValue = value => {\n  value = `${value}`;\n  if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);\n};\nconst find = (map, name) => {\n  name = name.toLowerCase();\n  for (const key in map) {\n    if (key.toLowerCase() === name) return key;\n  }\n  return undefined;\n};\nconst MAP = Symbol('map');\nclass Headers {\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    this[MAP] = Object.create(null);\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n      return;\n    }\n\n    // no-op\n    if (init === undefined || init === null) return;\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') throw new TypeError('Header pairs must be iterable');\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') throw new TypeError('Each header pair must be iterable');\n          const arrPair = Array.from(pair);\n          if (arrPair.length !== 2) throw new TypeError('Each header pair must be a name/value tuple');\n          pairs.push(arrPair);\n        }\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key]);\n        }\n      }\n    } else throw new TypeError('Provided initializer must be an object');\n  }\n  get(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key === undefined) return null;\n    return this[MAP][key].join(', ');\n  }\n  forEach(callback) {\n    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let pairs = getHeaders(this);\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i];\n      callback.call(thisArg, value, name, this);\n      // refresh in case the callback added more headers\n      pairs = getHeaders(this);\n    }\n  }\n  set(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    this[MAP][key !== undefined ? key : name] = [value];\n  }\n  append(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    if (key !== undefined) this[MAP][key].push(value);else this[MAP][name] = [value];\n  }\n  has(name) {\n    name = `${name}`;\n    validateName(name);\n    return find(this[MAP], name) !== undefined;\n  }\n  delete(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key !== undefined) delete this[MAP][key];\n  }\n  raw() {\n    return this[MAP];\n  }\n  keys() {\n    return new HeadersIterator(this, 'key');\n  }\n  values() {\n    return new HeadersIterator(this, 'value');\n  }\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value');\n  }\n  entries() {\n    return new HeadersIterator(this, 'key+value');\n  }\n  get [Symbol.toStringTag]() {\n    return 'Headers';\n  }\n  static exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP]);\n\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], 'Host');\n    if (hostHeaderKey !== undefined) obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    return obj;\n  }\n  static createHeadersLenient(obj) {\n    const headers = new Headers();\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name)) continue;\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val)) continue;\n          if (headers[MAP][name] === undefined) headers[MAP][name] = [val];else headers[MAP][name].push(val);\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [obj[name]];\n    }\n    return headers;\n  }\n}\nObject.defineProperties(Headers.prototype, {\n  get: {\n    enumerable: true\n  },\n  forEach: {\n    enumerable: true\n  },\n  set: {\n    enumerable: true\n  },\n  append: {\n    enumerable: true\n  },\n  has: {\n    enumerable: true\n  },\n  delete: {\n    enumerable: true\n  },\n  keys: {\n    enumerable: true\n  },\n  values: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  }\n});\nconst getHeaders = function (headers) {\n  let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n  return Object.keys(headers[MAP]).sort().map(kind === 'key' ? k => k.toLowerCase() : kind === 'value' ? k => headers[MAP][k].join(', ') : k => [k.toLowerCase(), headers[MAP][k].join(', ')]);\n};\nconst INTERNAL = Symbol('internal');\nclass HeadersIterator {\n  constructor(target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'HeadersIterator';\n  }\n  next() {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype) throw new TypeError('Value of `this` is not a HeadersIterator');\n    const {\n      target,\n      kind,\n      index\n    } = this[INTERNAL];\n    const values = getHeaders(target, kind);\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    this[INTERNAL].index++;\n    return {\n      value: values[index],\n      done: false\n    };\n  }\n}\n\n// manually extend because 'extends' requires a ctor\nObject.setPrototypeOf(HeadersIterator.prototype, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nmodule.exports = Headers;","map":{"version":3,"names":["invalidTokenRegex","invalidHeaderCharRegex","validateName","name","test","TypeError","validateValue","value","find","map","toLowerCase","key","undefined","MAP","Symbol","Headers","constructor","init","arguments","length","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","arrPair","Array","from","push","get","join","forEach","callback","thisArg","getHeaders","i","call","set","has","delete","HeadersIterator","values","entries","toStringTag","exportNodeCompatibleHeaders","headers","obj","assign","hostHeaderKey","createHeadersLenient","isArray","val","defineProperties","prototype","enumerable","kind","sort","k","INTERNAL","target","index","next","getPrototypeOf","len","done","setPrototypeOf","module","exports"],"sources":["/Users/user/node_modules/node-gyp/node_modules/minipass-fetch/lib/headers.js"],"sourcesContent":["'use strict'\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\nconst validateName = name => {\n  name = `${name}`\n  if (invalidTokenRegex.test(name) || name === '')\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n}\n\nconst validateValue = value => {\n  value = `${value}`\n  if (invalidHeaderCharRegex.test(value))\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n}\n\nconst find = (map, name) => {\n  name = name.toLowerCase()\n  for (const key in map) {\n    if (key.toLowerCase() === name)\n      return key\n  }\n  return undefined\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  constructor (init = undefined) {\n    this[MAP] = Object.create(null)\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n      return\n    }\n\n    // no-op\n    if (init === undefined || init === null)\n      return\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function')\n          throw new TypeError('Header pairs must be iterable')\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function')\n            throw new TypeError('Each header pair must be iterable')\n          const arrPair = Array.from(pair)\n          if (arrPair.length !== 2)\n            throw new TypeError('Each header pair must be a name/value tuple')\n          pairs.push(arrPair)\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key])\n        }\n      }\n    } else\n      throw new TypeError('Provided initializer must be an object')\n  }\n\n  get (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key === undefined)\n      return null\n\n    return this[MAP][key].join(', ')\n  }\n\n  forEach (callback, thisArg = undefined) {\n    let pairs = getHeaders(this)\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i]\n      callback.call(thisArg, value, name, this)\n      // refresh in case the callback added more headers\n      pairs = getHeaders(this)\n    }\n  }\n\n  set (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    this[MAP][key !== undefined ? key : name] = [value]\n  }\n\n  append (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      this[MAP][key].push(value)\n    else\n      this[MAP][name] = [value]\n  }\n\n  has (name) {\n    name = `${name}`\n    validateName(name)\n    return find(this[MAP], name) !== undefined\n  }\n\n  delete (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      delete this[MAP][key]\n  }\n\n  raw () {\n    return this[MAP]\n  }\n\n  keys () {\n    return new HeadersIterator(this, 'key')\n  }\n\n  values () {\n    return new HeadersIterator(this, 'value')\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  entries () {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Headers'\n  }\n\n  static exportNodeCompatibleHeaders (headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP])\n\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], 'Host')\n    if (hostHeaderKey !== undefined)\n      obj[hostHeaderKey] = obj[hostHeaderKey][0]\n\n    return obj\n  }\n\n  static createHeadersLenient (obj) {\n    const headers = new Headers()\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name))\n        continue\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val))\n            continue\n\n          if (headers[MAP][name] === undefined)\n            headers[MAP][name] = [val]\n          else\n            headers[MAP][name].push(val)\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name]))\n        headers[MAP][name] = [obj[name]]\n    }\n    return headers\n  }\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: { enumerable: true },\n  forEach: { enumerable: true },\n  set: { enumerable: true },\n  append: { enumerable: true },\n  has: { enumerable: true },\n  delete: { enumerable: true },\n  keys: { enumerable: true },\n  values: { enumerable: true },\n  entries: { enumerable: true },\n})\n\nconst getHeaders = (headers, kind = 'key+value') =>\n  Object.keys(headers[MAP]).sort().map(\n    kind === 'key' ? k => k.toLowerCase()\n    : kind === 'value' ? k => headers[MAP][k].join(', ')\n    : k => [k.toLowerCase(), headers[MAP][k].join(', ')]\n  )\n\nconst INTERNAL = Symbol('internal')\n\nclass HeadersIterator {\n  constructor (target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0,\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'HeadersIterator'\n  }\n\n  next () {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype)\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n\n    const { target, kind, index } = this[INTERNAL]\n    const values = getHeaders(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true,\n      }\n    }\n\n    this[INTERNAL].index++\n\n    return { value: values[index], done: false }\n  }\n}\n\n// manually extend because 'extends' requires a ctor\nObject.setPrototypeOf(HeadersIterator.prototype,\n  Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())))\n\nmodule.exports = Headers\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}